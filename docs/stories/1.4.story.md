# Story 1.4: Serviço de Análise de Sentimento (VADER)

## Status: Draft
## Epic: 1 - Backend (FastAPI + Apify)
## Points: 3

---

## Description

Como estrategista de campanha, quero que cada comentário coletado seja automaticamente classificado como positivo, negativo ou neutro usando o VADER, para que eu possa quantificar o sentimento público em relação a cada candidato de forma rápida e sem custo.

Esta story implementa o serviço de análise de sentimento usando `vaderSentiment`, com os thresholds definidos no PRD (compound >= 0.05 = positivo, compound <= -0.05 = negativo), processamento em batch de comentários não analisados, persistência em `sentiment_scores`, prevenção de análise duplicada, e os endpoints de trigger e sumário.

---

## Acceptance Criteria

- [ ] **AC1**: Given um texto de comentário, when `analyze_sentiment_vader(comment_text: str) -> SentimentResult` é chamado, then retorna um `SentimentResult` com:
  - `vader_compound`: score float no intervalo [-1.0, 1.0]
  - `vader_positive`: score positivo do VADER (pos)
  - `vader_negative`: score negativo do VADER (neg)
  - `vader_neutral`: score neutro do VADER (neu)
  - `vader_label`: `"positive"` se compound >= 0.05, `"negative"` se compound <= -0.05, `"neutral"` caso contrário

- [ ] **AC2**: Given os thresholds definidos nas constantes (`VADER_POSITIVE_THRESHOLD = 0.05`, `VADER_NEGATIVE_THRESHOLD = -0.05`), when `analyze_sentiment_vader()` processa valores de boundary, then:
  - compound = 0.05 → label = `"positive"`
  - compound = 0.049 → label = `"neutral"`
  - compound = -0.05 → label = `"negative"`
  - compound = -0.049 → label = `"neutral"`
  - compound = 0.0 → label = `"neutral"`

- [ ] **AC3**: Given uma lista de `Comment` objects, when `analyze_comments_batch(comments: list[Comment]) -> list[SentimentScore]` é chamado, then: (a) cada comentário é processado com `analyze_sentiment_vader()`; (b) um registro em `sentiment_scores` é criado para cada comentário com `vader_compound`, `vader_positive`, `vader_negative`, `vader_neutral`, `vader_label` preenchidos; (c) `final_label` é definido como `vader_label` (LLM fallback é Story 1.5); (d) `llm_label` e `llm_confidence` permanecem NULL; (e) a lista de `SentimentScore` criados é retornada.

- [ ] **AC4**: Given que um comentário já tem um registro em `sentiment_scores`, when `analyze_comments_batch()` é chamado novamente incluindo esse comentário, then o comentário é ignorado (não atualiza o registro existente). A função deve filtrar previamente quais comment_ids já têm sentiment_scores.

- [ ] **AC5**: Given que `POST /api/v1/analysis/sentiment` é chamado sem body, when processado, then: (a) todos os comentários SEM registro em `sentiment_scores` são identificados via query; (b) `analyze_comments_batch()` é invocado para eles; (c) a resposta `200 OK` é retornada com `{"analyzed_count": N, "skipped_count": M, "message": "Sentiment analysis complete"}`.

- [ ] **AC6**: Given que `GET /api/v1/analysis/sentiment/summary?candidate_id={uuid}` é chamado, when processado, then retorna `200 OK` com:
  ```json
  {
    "candidate_id": "uuid",
    "candidate_username": "charlles.evangelista",
    "total_comments": 500,
    "positive_count": 210,
    "negative_count": 140,
    "neutral_count": 150,
    "average_compound_score": 0.12
  }
  ```
  A query agrega via JOIN: `comments -> posts -> candidates` filtrando por `candidate_id`.

- [ ] **AC7**: Given que os unit tests existem em `tests/test_sentiment.py`, when `pytest tests/test_sentiment.py -k "vader"` é executado, then todos passam. Os testes cobrem:
  - Valores de boundary para os thresholds (0.05, -0.05, 0.049, -0.049, 0.0)
  - Batch processing: 5 comentários, todos sem registro prévio
  - Deduplicação: re-rodar batch com comentários já analisados -- skipped_count correto
  - Endpoint `/analysis/sentiment`: retorna contagens corretas com mock do Supabase
  - Endpoint `/analysis/sentiment/summary`: retorna agregação correta por candidato

---

## Scope

### IN
- `app/services/sentiment.py` -- `analyze_sentiment_vader()` e `analyze_comments_batch()`
- Query para identificar comentários não analisados (LEFT JOIN comments / sentiment_scores)
- INSERT de registros em `sentiment_scores`
- `app/routers/analysis.py` -- endpoints `POST /api/v1/analysis/sentiment` e `GET /api/v1/analysis/sentiment/summary`
- `app/main.py` -- registrar `analysis.router`
- `tests/test_sentiment.py` -- testes de VADER

### OUT
- LLM fallback para comentários ambíguos (Story 1.5)
- Extração de temas (Story 1.6)
- Atualização de `final_label` pelo LLM (Story 1.5)

---

## Dependencies

- Story 1.1 concluída (configuração, modelos, cliente Supabase)
- Stories 1.2 e 1.3 concluídas (comentários devem existir no banco)
- `vaderSentiment` presente em `requirements.txt`

---

## Technical Notes

### VADER Usage

```python
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

_analyzer = SentimentIntensityAnalyzer()

def analyze_sentiment_vader(comment_text: str) -> SentimentResult:
    scores = _analyzer.polarity_scores(comment_text)
    compound = scores["compound"]
    label = (
        "positive" if compound >= VADER_POSITIVE_THRESHOLD
        else "negative" if compound <= VADER_NEGATIVE_THRESHOLD
        else "neutral"
    )
    return SentimentResult(
        vader_compound=compound,
        vader_positive=scores["pos"],
        vader_negative=scores["neg"],
        vader_neutral=scores["neu"],
        vader_label=label,
    )
```

### Schema da Tabela sentiment_scores (SCHEMA.md Seção 3.5)

Campos a preencher nesta story (LLM campos ficam NULL):
- `comment_id` (UUID, FK)
- `vader_compound` (DOUBLE PRECISION, NOT NULL)
- `vader_positive`, `vader_negative`, `vader_neutral` (DOUBLE PRECISION, optional)
- `vader_label` (sentiment_label enum, NOT NULL)
- `final_label` = `vader_label` (sentiment_label enum, NOT NULL)
- `llm_label` = NULL
- `llm_confidence` = NULL
- `llm_model` = NULL

### Query para Comentários Não Analisados (SCHEMA.md Seção 5 -- função `get_unanalyzed_comment_ids`)

```python
# Usando a função PL/pgSQL definida nas migrations
result = supabase.rpc("get_unanalyzed_comment_ids", {"limit_val": 1000}).execute()
```

Ou via SDK select:
```python
# Comments sem sentiment_score associado
result = supabase.table("comments").select("id, text").execute()
analyzed_ids = supabase.table("sentiment_scores").select("comment_id").execute()
# Filtrar comentários não presentes em analyzed_ids
```

### Query para Summary por Candidato

JOIN necessário: `sentiment_scores -> comments -> posts -> candidates`
- Agregar por `final_label`, calcular AVG(`vader_compound`)

### Endpoints Envolvidos (architecture.md Seção 3.2.3)

- `POST /api/v1/analysis/sentiment`
  - Response: `{"analyzed_count": 342, "skipped_count": 58, "message": "Sentiment analysis complete"}`
- `GET /api/v1/analysis/sentiment/summary?candidate_id={uuid}`
  - Response: objeto com contagens e score médio

### Tabelas Envolvidas
- `comments` (SELECT para processar em batch)
- `sentiment_scores` (INSERT novos registros)
- `candidates` (resolução de username em summary endpoint)
- `posts` (JOIN para filtrar por candidate_id)

### PRD References
- FR-003: Sentiment Analysis (VADER Primary) -- thresholds exatos definidos
- NFR-003: Portuguese Language Support -- VADER tem viés inglês, aceitável como baseline
- NFR-004: Scalability -- batch processing para 10K comentários

### Nota sobre Português (NFR-003)

VADER é otimizado para inglês. A precisão para português é limitada mas aceitável como baseline. O LLM fallback (Story 1.5) compensa para casos ambíguos. Não customizar o VADER para português nesta story -- isso está fora do escopo do MVP.

---

## File List

| Arquivo | Acao |
|---------|------|
| `app/services/sentiment.py` | Criar -- `analyze_sentiment_vader()` e `analyze_comments_batch()` |
| `app/routers/analysis.py` | Criar -- `POST /analysis/sentiment` e `GET /analysis/sentiment/summary` |
| `app/main.py` | Modificar -- registrar `analysis.router` |
| `tests/test_sentiment.py` | Criar -- testes de VADER |

---

## Dev Notes

<!-- @dev: Espaço para anotar decisões durante implementação -->
<!-- vaderSentiment é síncrono e muito rápido (~1ms/comentário) -- batch de 10K é viável em poucos segundos -->
<!-- O `SentimentIntensityAnalyzer` pode ser instanciado como módulo-level singleton para evitar overhead de inicialização por chamada -->
<!-- Para o summary endpoint, verificar se a função PL/pgSQL `get_candidate_overview` já retorna esse dado -- se sim, pode ser reaproveitada -->
<!-- AC6 query: candidato pode não ter nenhum comentário analisado ainda -- retornar zeros, não erro 404 -->

---

## Change Log

| Data | Autor | Descricao |
|------|-------|-----------|
| 2026-02-21 | River (SM) | Story criada |
